# Pismo Technical Assessment - Transactions API

This project is a financial services API for account management and transaction processing, developed as part of the Pismo technical challenge.

## ğŸ¯ Architectural Decisions & Project Structure

The solution was built using **Hexagonal Architecture (Ports & Adapters)**. This choice ensures:

* **Domain Isolation:** Business rules (such as transaction signal inversion) are independent of frameworks and databases.
* **Testability:** Ease of testing the application core without relying on external infrastructure.
* **Maintainability:** Clear separation of concerns following the **Single Responsibility Principle**.

The code is organized into three main layers to strictly follow the pattern:

```text
src/main/java/com/pismo/transactions/
â”œâ”€â”€ domain/                         # 1. CORE DOMAIN (The Hexagon Center)
â”‚   â”œâ”€â”€ model/                      # Business entities (e.g., Account, Transaction)
â”‚   â”œâ”€â”€ exceptions/                 # Custom business and domain exceptions
â”‚       â”œâ”€â”€ enums/                      # Business rules logic (e.g., OperationType)
â”‚   â””â”€â”€ ports/                      # Boundaries (Interfaces for Inbound/Outbound)
â”‚
â”œâ”€â”€ application/                    # 2. APPLICATION LAYER (Use Cases)
â”‚   â””â”€â”€ usecase/                    # Orchestration of domain logic
â”‚
â””â”€â”€ infrastructure/                 # 3. INFRASTRUCTURE LAYER (Adapters)
    â”œâ”€â”€ adapters/
    â”‚   â”œâ”€â”€ in/web/                 # PRIMARY ADAPTERS (Driving)
    â”‚   â”‚   â”œâ”€â”€ docs/               # Swagger/OpenAPI interactive documentation
    â”‚   â”‚   â”œâ”€â”€ dto/                # Request/Response Data Transfer Objects
    â”‚   â”‚   â””â”€â”€ mapper/             # Conversion: Domain â†” DTO (MapStruct)
    â”‚   â”‚
    â”‚   â””â”€â”€ out/persistence/        # SECONDARY ADAPTERS (Driven)
    â”‚       â”œâ”€â”€ entity/             # JPA Entities (Database mapping)
    â”‚       â”œâ”€â”€ repository/         # Spring Data JPA Interfaces
    â”‚       â””â”€â”€ mapper/             # Conversion: Domain â†” Entity
    â”‚
    â””â”€â”€ configuration/              # FRAMEWORK CONFIGURATION
        â””â”€â”€ bean/                   # Manual Bean registration (Inversion of Control)
```

---

## ğŸ›  Tech Stack

* **Java 17** & **Spring Boot 4.0.2**
* **PostgreSQL** (Relational database)
* **Flyway** (Database migrations and initial data seeding)
* **Docker & Docker Compose** (Containerization)
* **MapStruct** (High-performance object mapping)
* **Bean Validation** (Input contract validation)
* **OpenAPI 3 (Swagger)** (Interactive API documentation)

---
## ğŸ“¦ Build Configuration & Dependency Management

The project's `pom.xml` is designed for high performance and strict modularity, leveraging **Spring Boot 4.0.2** and **Spring Framework 7**.

### ğŸ›  Core Dependencies
* **Spring Boot Starters (Web, Validation, Data JPA):** I used modular starters to keep the application context lean. Validation is handled via *Bean Validation* to ensure the integrity of input data (Account IDs and Amounts).
* **Flyway & PostgreSQL:** Schema management is handled through migrations. The `flyway-database-postgresql` dependency is included for specific support of PostgreSQL 15+ features and data types.
* **MapStruct & Lombok:** A strategic choice for performance. MapStruct generates mapping code at **compile-time**. Unlike reflection-based mappers, this ensures the application is extremely fast and type-safe.
* **SpringDoc OpenAPI (Swagger):** Automated documentation compliant with Jakarta EE 10, providing an interactive UI for endpoint testing.



### ğŸ§ª Modular Testing Infrastructure
Following Spring Boot 4's new testing architecture, I utilized **Test Slices** to optimize resources and build time:
* **`spring-boot-starter-webmvc-test`:** Focuses exclusively on the Controller layer and HTTP contracts.
* **`spring-boot-starter-data-jpa-test`:** Isolates the persistence layer to validate ORM mappings and repository queries.
* **Testcontainers & @ServiceConnection:** Instead of using in-memory databases (H2), I used a real **PostgreSQL 15** instance via Docker. The `@ServiceConnection` annotation (new in Spring Boot 4) automates JDBC discovery, making integration tests robust and identical to production.



### âš™ï¸ Compiler Configuration (Lombok-MapStruct Binding)
The `maven-compiler-plugin` is configured with a strict **Annotation Processor Path** to orchestrate the build flow:
1. **Lombok:** Runs first to generate the necessary bytecode (getters/setters).
2. **Lombok-MapStruct-Binding:** Acts as a bridge so MapStruct can "see" the code generated by Lombok.
3. **MapStruct-Processor:** Finally generates the `MapperImpl` classes, ensuring they are ready for dependency injection.


---
## ğŸ“ Technical Implementation Notes

To ensure a high-quality delivery that balances the technical requirements of the PDF with best practices in Software Engineering, the following decisions were made:

### 1. Naming Convention & Database Compatibility
* **Decision:** Explicit `@Column` mapping (e.g., `@Column(name = "EventDate")`).
* **Justification:** To maintain strict adherence to the naming convention defined in the project specification (PDF), I used explicit JPA mappings. This prevents Hibernate's default naming strategy from converting fields to `snake_case` (like `event_date`), ensuring perfect synchronization with the PostgreSQL schema provided.

### ğŸ”§ Database Naming Strategy
* **Decision:** Implementation of `PhysicalNamingStrategyStandardImpl`.
* **Justification:** To ensure 100% fidelity to the data model defined in the technical requirements (PDF), I chose to override Hibernate's default naming convention (which forces snake_case). This strategy ensures that the application respects the exact casing of columns like `EventDate` and `Account_ID`, prioritizing correct system integration over framework defaults.

### 2. Document Validation (CPF/CNPJ)
* **Decision:** Standard `String` for `document_number`.
* **Justification:** In compliance with the project's contract, the document is handled as a simple string. However, I am fully aware that in a production-ready financial environment, robust validation (such as `@CPF` from Hibernate Validator) would be mandatory to ensure data integrity and prevent fraudulent entries.


---
## ğŸš€ Getting Started

### Prerequisites:
* Docker and Docker Compose installed.

### ğŸ” Security & Configuration (.env)
Following the **12-Factor App** methodology, this project manages sensitive information via environment variables to ensure security and portability.

* **Environment Variables:** Credentials like database passwords and connection strings are stored in a `.env` file.
* **Automated Migrations:** Database schema and initial data (Operation Types) are managed by **Flyway**, which also consumes these environment variables for secure deployments.
* **Security First:** The `.env` file is ignored by Git to prevent leaking sensitive data in the version control history.

### Setup:
1.  **Prepare the Environment:** Create your local `.env` file from the provided example:
    ```bash
    cp .env.example .env
    ```
2.  **Spin up the Containers:** In the project root, run:
    ```bash
    docker-compose up --build -d
    ```
3.  **Wait & Verify:** Once the containers are healthy, the API will be available at: `http://localhost:8080`
4.  **Interactive Docs:** Access Swagger at: `http://localhost:8080/swagger-ui/index.html`

### ğŸ§¹ Cleanup
To stop the application and remove the database volumes:
```bash
docker-compose down -v
```

---

## ğŸ“– API Documentation

### Main Endpoints:

#### 1. Accounts
* `POST /accounts`: Registers a new customer account.
* `GET /accounts/{id}`: Retrieves details for a specific account.

#### 2. Transactions
* `POST /transactions`: Processes a financial transaction following signal rules.

### Signal Rules (Requirement 3.2):
The API processes the `amount` field based on the operation type:

| ID | Description | Signal Behavior |
| :--- | :--- | :--- |
| 1 | PURCHASE | Recorded as Negative |
| 2 | INSTALLMENT PURCHASE | Recorded as Negative |
| 3 | WITHDRAWAL | Recorded as Negative |
| 4 | PAYMENT | Recorded as Positive |



---

## ğŸ§ª Testing

## ğŸ”¬ Testing Strategy

The project employs a robust testing pyramid to ensure reliability across all layers of the Hexagonal Architecture, achieving high code coverage:

* **Unit Tests:** Focus on core domain logic, such as transaction amount signal inversion rules based on the `OperationType`. These tests run in total isolation without loading the Spring context, ensuring sub-second execution.
* **Integration Tests (IT):** Employs **Testcontainers** to spin up a real **PostgreSQL 15-alpine** instance for the persistence layer.
    * Utilizes the Spring Boot 4 `@ServiceConnection` for seamless, zero-config database integration.
    * Validates JPA mappings, database constraints, and repository behavior against a production-grade database.
    * Bypasses Flyway in the test slice using `spring.jpa.hibernate.ddl-auto=create-drop` to ensure a clean and fast environment for adapter validation.
* **API Slice Tests:** Uses `@WebMvcTest` and `MockMvc` to validate HTTP contracts, Jackson serialization/deserialization, and the **Global REST Advice**.
    * Leverages the Spring Boot 4 `@MockitoBean` system to isolate controllers from application use cases while ensuring high coverage of the **GlobalExceptionHandler**.

### ğŸš€ Running the Suite
To execute all tests (Unit + Integration):
```bash
./mvnw test
```

### ğŸ•¹ï¸ Manual Verification
After starting the containers with Docker, you can use *Swagger UI* or `curl` for manual testing:

```bash
curl -X POST http://localhost:8080/accounts \
     -H "Content-Type: application/json" \
     -d '{"document_number": "12345678900"}'
```

*Create Transaction:*
```bash
curl -X POST http://localhost:8080/transactions \
     -H "Content-Type: application/json" \
     -d '{"account_id": 1, "operation_type_id": 1, "amount": 100.00}'
```
